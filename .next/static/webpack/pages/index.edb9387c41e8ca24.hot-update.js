/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("document.getElementById(\"simulate-button\").addEventListener(\"click\", simulateCache);\nfunction simulateCache() {\n    const blockSize = 2; // Block size in words\n    const mainMemorySize = 8; // Number of blocks in main memory\n    const cacheMemorySize = 4; // Number of blocks in cache\n    const cacheAccessTime = 1; // ns\n    const memoryAccessTime = 10; // ns\n    const setSize = 2; // Number of blocks per set\n    const programFlowInput = \"0, 2, 4, 0, 2, 6\"; // Program flow\n    const missPenalty = memoryAccessTime; // Miss penalty is equal to memory access time\n    const programFlow = programFlowInput.split(\",\").map(Number);\n    // Initialize cache (2 sets with 2 blocks each)\n    let cache = [\n        [],\n        []\n    ]; // Cache is organized into sets\n    let cacheSets = 2; // Number of sets\n    let cacheBlocksPerSet = setSize; // Number of blocks per set\n    let mainMemory = new Array(mainMemorySize).fill(null).map((_, index)=>index); // Dummy main memory\n    let hits = 0;\n    let misses = 0;\n    let time = 0;\n    function findSetIndex(address) {\n        return Math.floor(address / (mainMemorySize / cacheSets)) % cacheSets;\n    }\n    programFlow.forEach((address)=>{\n        let block = address; // Block number (in this case, address itself is the block number)\n        let setIndex = findSetIndex(block);\n        let set = cache[setIndex];\n        let index = set.findIndex((entry)=>entry.block === block);\n        if (index !== -1) {\n            // Cache hit\n            hits++;\n            set[index].time = time;\n        } else {\n            // Cache miss\n            misses++;\n            if (set.length < cacheBlocksPerSet) {\n                set.push({\n                    block,\n                    time\n                });\n            } else {\n                // LRU replacement\n                set.sort((a, b)=>a.time - b.time);\n                set[0] = {\n                    block,\n                    time\n                };\n            }\n            time += missPenalty;\n        }\n        time += cacheAccessTime;\n    });\n    let averageAccessTime = time / programFlow.length;\n    let totalAccessTime = time;\n    // Output results\n    document.getElementById(\"hits\").innerText = \"Hits: \".concat(hits, \"/\").concat(programFlow.length);\n    document.getElementById(\"misses\").innerText = \"Misses: \".concat(misses, \"/\").concat(programFlow.length);\n    document.getElementById(\"miss-penalty-output\").innerText = \"Miss Penalty: \".concat(missPenalty);\n    document.getElementById(\"average-access-time\").innerText = \"Average Memory Access Time: \".concat(averageAccessTime);\n    document.getElementById(\"total-access-time\").innerText = \"Total Memory Access Time: \".concat(totalAccessTime);\n    // Display cache snapshot\n    let cacheSnapshot = cache.map((set, setIndex)=>\"Set \".concat(setIndex, \": \").concat(set.map((entry)=>\"Block: \".concat(entry.block, \", Time: \").concat(entry.time)).join(\", \"))).join(\"\\n\");\n    document.getElementById(\"cache-snapshot\").innerText = cacheSnapshot;\n}\ndocument.getElementById(\"download-results\").addEventListener(\"click\", downloadResults);\nfunction downloadResults() {\n    let resultText = \"\\n        Hits: \".concat(document.getElementById(\"hits\").innerText, \"\\n        Misses: \").concat(document.getElementById(\"misses\").innerText, \"\\n        Miss Penalty: \").concat(document.getElementById(\"miss-penalty-output\").innerText, \"\\n        Average Memory Access Time: \").concat(document.getElementById(\"average-access-time\").innerText, \"\\n        Total Memory Access Time: \").concat(document.getElementById(\"total-access-time\").innerText, \"\\n        Cache Snapshot: \").concat(document.getElementById(\"cache-snapshot\").innerText, \"\\n    \");\n    let blob = new Blob([\n        resultText\n    ], {\n        type: \"text/plain\"\n    });\n    let link = document.createElement(\"a\");\n    link.href = URL.createObjectURL(blob);\n    link.download = \"cache_simulation_results.txt\";\n    link.click();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aEMsT0FBb0JDLE9BQWJELFVBQVMsTUFBOEUsT0FBMUVDLElBQUlwQixHQUFHLENBQUNzQixDQUFBQSxRQUFTLFVBQWdDQSxPQUF0QkEsTUFBTUosS0FBSyxFQUFDLFlBQXFCLE9BQVhJLE1BQU1WLElBQUksR0FBSW9CLElBQUksQ0FBQyxRQUMxRkEsSUFBSSxDQUFDO0lBQ1A5QyxTQUFTQyxjQUFjLENBQUMsa0JBQWtCMkMsU0FBUyxHQUFHQztBQUMxRDtBQUVBN0MsU0FBU0MsY0FBYyxDQUFDLG9CQUFvQkMsZ0JBQWdCLENBQUMsU0FBUzZDO0FBRXRFLFNBQVNBO0lBQ0wsSUFBSUMsYUFBYSxtQkFFSGhELE9BREZBLFNBQVNDLGNBQWMsQ0FBQyxRQUFRMkMsU0FBUyxFQUFDLHNCQUVsQzVDLE9BRE5BLFNBQVNDLGNBQWMsQ0FBQyxVQUFVMkMsU0FBUyxFQUFDLDRCQUV4QjVDLE9BRGRBLFNBQVNDLGNBQWMsQ0FBQyx1QkFBdUIyQyxTQUFTLEVBQUMsMENBRTdDNUMsT0FERUEsU0FBU0MsY0FBYyxDQUFDLHVCQUF1QjJDLFNBQVMsRUFBQyx3Q0FFckU1QyxPQURVQSxTQUFTQyxjQUFjLENBQUMscUJBQXFCMkMsU0FBUyxFQUFDLDhCQUNiLE9BQXBENUMsU0FBU0MsY0FBYyxDQUFDLGtCQUFrQjJDLFNBQVMsRUFBQztJQUUxRSxJQUFJSyxPQUFPLElBQUlDLEtBQUs7UUFBQ0Y7S0FBVyxFQUFFO1FBQUVHLE1BQU07SUFBYTtJQUN2RCxJQUFJQyxPQUFPcEQsU0FBU3FELGFBQWEsQ0FBQztJQUNsQ0QsS0FBS0UsSUFBSSxHQUFHQyxJQUFJQyxlQUFlLENBQUNQO0lBQ2hDRyxLQUFLSyxRQUFRLEdBQUc7SUFDaEJMLEtBQUtNLEtBQUs7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9pbmRleC5qcz9iZWU3Il0sInNvdXJjZXNDb250ZW50IjpbImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaW11bGF0ZS1idXR0b24nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNpbXVsYXRlQ2FjaGUpO1xuXG5mdW5jdGlvbiBzaW11bGF0ZUNhY2hlKCkge1xuICAgIGNvbnN0IGJsb2NrU2l6ZSA9IDI7IC8vIEJsb2NrIHNpemUgaW4gd29yZHNcbiAgICBjb25zdCBtYWluTWVtb3J5U2l6ZSA9IDg7IC8vIE51bWJlciBvZiBibG9ja3MgaW4gbWFpbiBtZW1vcnlcbiAgICBjb25zdCBjYWNoZU1lbW9yeVNpemUgPSA0OyAvLyBOdW1iZXIgb2YgYmxvY2tzIGluIGNhY2hlXG4gICAgY29uc3QgY2FjaGVBY2Nlc3NUaW1lID0gMTsgLy8gbnNcbiAgICBjb25zdCBtZW1vcnlBY2Nlc3NUaW1lID0gMTA7IC8vIG5zXG4gICAgY29uc3Qgc2V0U2l6ZSA9IDI7IC8vIE51bWJlciBvZiBibG9ja3MgcGVyIHNldFxuICAgIGNvbnN0IHByb2dyYW1GbG93SW5wdXQgPSAnMCwgMiwgNCwgMCwgMiwgNic7IC8vIFByb2dyYW0gZmxvd1xuICAgIGNvbnN0IG1pc3NQZW5hbHR5ID0gbWVtb3J5QWNjZXNzVGltZTsgLy8gTWlzcyBwZW5hbHR5IGlzIGVxdWFsIHRvIG1lbW9yeSBhY2Nlc3MgdGltZVxuXG4gICAgY29uc3QgcHJvZ3JhbUZsb3cgPSBwcm9ncmFtRmxvd0lucHV0LnNwbGl0KCcsJykubWFwKE51bWJlcik7XG5cbiAgICAvLyBJbml0aWFsaXplIGNhY2hlICgyIHNldHMgd2l0aCAyIGJsb2NrcyBlYWNoKVxuICAgIGxldCBjYWNoZSA9IFtbXSwgW11dOyAvLyBDYWNoZSBpcyBvcmdhbml6ZWQgaW50byBzZXRzXG4gICAgbGV0IGNhY2hlU2V0cyA9IDI7IC8vIE51bWJlciBvZiBzZXRzXG4gICAgbGV0IGNhY2hlQmxvY2tzUGVyU2V0ID0gc2V0U2l6ZTsgLy8gTnVtYmVyIG9mIGJsb2NrcyBwZXIgc2V0XG5cbiAgICBsZXQgbWFpbk1lbW9yeSA9IG5ldyBBcnJheShtYWluTWVtb3J5U2l6ZSkuZmlsbChudWxsKS5tYXAoKF8sIGluZGV4KSA9PiBpbmRleCk7IC8vIER1bW15IG1haW4gbWVtb3J5XG5cbiAgICBsZXQgaGl0cyA9IDA7XG4gICAgbGV0IG1pc3NlcyA9IDA7XG4gICAgbGV0IHRpbWUgPSAwO1xuXG4gICAgZnVuY3Rpb24gZmluZFNldEluZGV4KGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoYWRkcmVzcyAvIChtYWluTWVtb3J5U2l6ZSAvIGNhY2hlU2V0cykpICUgY2FjaGVTZXRzO1xuICAgIH1cblxuICAgIHByb2dyYW1GbG93LmZvckVhY2goYWRkcmVzcyA9PiB7XG4gICAgICAgIGxldCBibG9jayA9IGFkZHJlc3M7IC8vIEJsb2NrIG51bWJlciAoaW4gdGhpcyBjYXNlLCBhZGRyZXNzIGl0c2VsZiBpcyB0aGUgYmxvY2sgbnVtYmVyKVxuICAgICAgICBsZXQgc2V0SW5kZXggPSBmaW5kU2V0SW5kZXgoYmxvY2spO1xuICAgICAgICBsZXQgc2V0ID0gY2FjaGVbc2V0SW5kZXhdO1xuICAgICAgICBsZXQgaW5kZXggPSBzZXQuZmluZEluZGV4KGVudHJ5ID0+IGVudHJ5LmJsb2NrID09PSBibG9jayk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gQ2FjaGUgaGl0XG4gICAgICAgICAgICBoaXRzKys7XG4gICAgICAgICAgICBzZXRbaW5kZXhdLnRpbWUgPSB0aW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FjaGUgbWlzc1xuICAgICAgICAgICAgbWlzc2VzKys7XG4gICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA8IGNhY2hlQmxvY2tzUGVyU2V0KSB7XG4gICAgICAgICAgICAgICAgc2V0LnB1c2goeyBibG9jaywgdGltZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTFJVIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgc2V0LnNvcnQoKGEsIGIpID0+IGEudGltZSAtIGIudGltZSk7XG4gICAgICAgICAgICAgICAgc2V0WzBdID0geyBibG9jaywgdGltZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZSArPSBtaXNzUGVuYWx0eTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lICs9IGNhY2hlQWNjZXNzVGltZTtcbiAgICB9KTtcblxuICAgIGxldCBhdmVyYWdlQWNjZXNzVGltZSA9IHRpbWUgLyBwcm9ncmFtRmxvdy5sZW5ndGg7XG4gICAgbGV0IHRvdGFsQWNjZXNzVGltZSA9IHRpbWU7XG5cbiAgICAvLyBPdXRwdXQgcmVzdWx0c1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoaXRzJykuaW5uZXJUZXh0ID0gYEhpdHM6ICR7aGl0c30vJHtwcm9ncmFtRmxvdy5sZW5ndGh9YDtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWlzc2VzJykuaW5uZXJUZXh0ID0gYE1pc3NlczogJHttaXNzZXN9LyR7cHJvZ3JhbUZsb3cubGVuZ3RofWA7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pc3MtcGVuYWx0eS1vdXRwdXQnKS5pbm5lclRleHQgPSBgTWlzcyBQZW5hbHR5OiAke21pc3NQZW5hbHR5fWA7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F2ZXJhZ2UtYWNjZXNzLXRpbWUnKS5pbm5lclRleHQgPSBgQXZlcmFnZSBNZW1vcnkgQWNjZXNzIFRpbWU6ICR7YXZlcmFnZUFjY2Vzc1RpbWV9YDtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG90YWwtYWNjZXNzLXRpbWUnKS5pbm5lclRleHQgPSBgVG90YWwgTWVtb3J5IEFjY2VzcyBUaW1lOiAke3RvdGFsQWNjZXNzVGltZX1gO1xuXG4gICAgLy8gRGlzcGxheSBjYWNoZSBzbmFwc2hvdFxuICAgIGxldCBjYWNoZVNuYXBzaG90ID0gY2FjaGUubWFwKChzZXQsIHNldEluZGV4KSA9PiBcbiAgICAgICAgYFNldCAke3NldEluZGV4fTogJHtzZXQubWFwKGVudHJ5ID0+IGBCbG9jazogJHtlbnRyeS5ibG9ja30sIFRpbWU6ICR7ZW50cnkudGltZX1gKS5qb2luKCcsICcpfWBcbiAgICApLmpvaW4oJ1xcbicpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWNoZS1zbmFwc2hvdCcpLmlubmVyVGV4dCA9IGNhY2hlU25hcHNob3Q7XG59XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkb3dubG9hZC1yZXN1bHRzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBkb3dubG9hZFJlc3VsdHMpO1xuXG5mdW5jdGlvbiBkb3dubG9hZFJlc3VsdHMoKSB7XG4gICAgbGV0IHJlc3VsdFRleHQgPSBgXG4gICAgICAgIEhpdHM6ICR7ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hpdHMnKS5pbm5lclRleHR9XG4gICAgICAgIE1pc3NlczogJHtkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWlzc2VzJykuaW5uZXJUZXh0fVxuICAgICAgICBNaXNzIFBlbmFsdHk6ICR7ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pc3MtcGVuYWx0eS1vdXRwdXQnKS5pbm5lclRleHR9XG4gICAgICAgIEF2ZXJhZ2UgTWVtb3J5IEFjY2VzcyBUaW1lOiAke2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdmVyYWdlLWFjY2Vzcy10aW1lJykuaW5uZXJUZXh0fVxuICAgICAgICBUb3RhbCBNZW1vcnkgQWNjZXNzIFRpbWU6ICR7ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsLWFjY2Vzcy10aW1lJykuaW5uZXJUZXh0fVxuICAgICAgICBDYWNoZSBTbmFwc2hvdDogJHtkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FjaGUtc25hcHNob3QnKS5pbm5lclRleHR9XG4gICAgYDtcbiAgICBsZXQgYmxvYiA9IG5ldyBCbG9iKFtyZXN1bHRUZXh0XSwgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XG4gICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICBsaW5rLmRvd25sb2FkID0gJ2NhY2hlX3NpbXVsYXRpb25fcmVzdWx0cy50eHQnO1xuICAgIGxpbmsuY2xpY2soKTtcbn1cbiJdLCJuYW1lcyI6WyJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNpbXVsYXRlQ2FjaGUiLCJibG9ja1NpemUiLCJtYWluTWVtb3J5U2l6ZSIsImNhY2hlTWVtb3J5U2l6ZSIsImNhY2hlQWNjZXNzVGltZSIsIm1lbW9yeUFjY2Vzc1RpbWUiLCJzZXRTaXplIiwicHJvZ3JhbUZsb3dJbnB1dCIsIm1pc3NQZW5hbHR5IiwicHJvZ3JhbUZsb3ciLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImNhY2hlIiwiY2FjaGVTZXRzIiwiY2FjaGVCbG9ja3NQZXJTZXQiLCJtYWluTWVtb3J5IiwiQXJyYXkiLCJmaWxsIiwiXyIsImluZGV4IiwiaGl0cyIsIm1pc3NlcyIsInRpbWUiLCJmaW5kU2V0SW5kZXgiLCJhZGRyZXNzIiwiTWF0aCIsImZsb29yIiwiZm9yRWFjaCIsImJsb2NrIiwic2V0SW5kZXgiLCJzZXQiLCJmaW5kSW5kZXgiLCJlbnRyeSIsImxlbmd0aCIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJhdmVyYWdlQWNjZXNzVGltZSIsInRvdGFsQWNjZXNzVGltZSIsImlubmVyVGV4dCIsImNhY2hlU25hcHNob3QiLCJqb2luIiwiZG93bmxvYWRSZXN1bHRzIiwicmVzdWx0VGV4dCIsImJsb2IiLCJCbG9iIiwidHlwZSIsImxpbmsiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImRvd25sb2FkIiwiY2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.js\n"));

/***/ })

});