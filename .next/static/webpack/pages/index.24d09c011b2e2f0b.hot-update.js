/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("if (true) {\n    document.getElementById(\"simulate-button\").addEventListener(\"click\", simulateCache);\n    function simulateCache() {\n        const blockSize = parseInt(document.getElementById(\"block-size\").value);\n        const mainMemoryInput = document.getElementById(\"main-memory\").value;\n        const mainMemoryType = document.querySelector(\"#main-memory-type\").value;\n        const cacheMemoryInput = document.getElementById(\"cache-memory\").value;\n        const cacheMemoryType = document.querySelector(\"#cache-memory-type\").value;\n        const programFlowInput = document.getElementById(\"program-flow\").value;\n        const cacheAccessTime = parseInt(document.getElementById(\"cache-access-time\").value);\n        const memoryAccessTime = parseInt(document.getElementById(\"memory-access-time\").value);\n        // Convert program flow input into blocks if necessary\n        const programFlow = programFlowInput.split(\",\").map(Number);\n        // Convert main memory size and cache memory size into blocks\n        const mainMemorySize = mainMemoryType === \"blocks\" ? parseInt(mainMemoryInput) : Math.ceil(parseInt(mainMemoryInput) / blockSize);\n        const cacheMemorySize = cacheMemoryType === \"blocks\" ? parseInt(cacheMemoryInput) : Math.ceil(parseInt(cacheMemoryInput) / blockSize);\n        // Initialize cache and main memory\n        let cache = [];\n        let mainMemory = new Array(mainMemorySize).fill(null).map((_, index)=>index);\n        let hits = 0;\n        let misses = 0;\n        let time = 0;\n        // Cache structure\n        const cacheBlocks = cacheMemorySize;\n        const cacheData = new Array(cacheBlocks).fill(null);\n        const cacheTime = new Array(cacheBlocks).fill(0);\n        // Track time\n        let currentTime = 0;\n        programFlow.forEach((address)=>{\n            let block = Math.floor(address / blockSize);\n            let index = cacheData.indexOf(block);\n            if (index !== -1) {\n                // Cache hit\n                hits++;\n                time += cacheAccessTime; // Add cache access time on hit\n                cacheTime[index] = ++currentTime;\n            } else {\n                // Cache miss\n                misses++;\n                time += memoryAccessTime; // Add memory access time on miss\n                if (cacheData.length < cacheMemorySize) {\n                    // Cache not full, just add new block\n                    cacheData[cacheData.indexOf(null)] = block;\n                } else {\n                    // Cache full, replace least recently used block\n                    let lruIndex = cacheTime.indexOf(Math.min(...cacheTime));\n                    cacheData[lruIndex] = block;\n                    cacheTime[lruIndex] = ++currentTime;\n                }\n            }\n            currentTime++; // Add 1 unit of time for the memory access\n        });\n        // Calculations\n        const totalAccesses = programFlow.length;\n        const hitRate = hits / totalAccesses;\n        const missRate = misses / totalAccesses;\n        const missPenalty = 11; // given\n        const averageAccessTime = hitRate * cacheAccessTime + missRate * missPenalty;\n        const totalAccessTime = hits * blockSize * cacheAccessTime + misses * blockSize * missPenalty + misses * cacheAccessTime;\n        // Display results\n        document.getElementById(\"hits\").innerText = \"Cache Hits: \".concat(hits, \"/\").concat(totalAccesses);\n        document.getElementById(\"misses\").innerText = \"Cache Misses: \".concat(misses, \"/\").concat(totalAccesses);\n        document.getElementById(\"average-access-time\").innerText = \"Average Memory Access Time: \".concat(averageAccessTime.toFixed(2), \"ns\");\n        document.getElementById(\"total-access-time\").innerText = \"Total Memory Access Time: \".concat(totalAccessTime, \"ns\");\n        // Cache snapshot\n        let cacheSnapshot = cacheData.map((block, idx)=>\"Block \".concat(idx, \": \").concat(block)).join(\"\\n\");\n        document.getElementById(\"cache-snapshot\").innerText = cacheSnapshot;\n    }\n    document.getElementById(\"download-results\").addEventListener(\"click\", downloadResults);\n    function downloadResults() {\n        let resultText = \"\\n      Hits: \".concat(document.getElementById(\"hits\").innerText, \"\\n      Misses: \").concat(document.getElementById(\"misses\").innerText, \"\\n      Average Memory Access Time: \").concat(document.getElementById(\"average-access-time\").innerText, \"\\n      Total Memory Access Time: \").concat(document.getElementById(\"total-access-time\").innerText, \"\\n      Cache Snapshot: \").concat(document.getElementById(\"cache-snapshot\").innerText, \"\\n    \");\n        let blob = new Blob([\n            resultText\n        ], {\n            type: \"text/plain\"\n        });\n        let link = document.createElement(\"a\");\n        link.href = URL.createObjectURL(blob);\n        link.download = \"cache_simulation_results.txt\";\n        link.click();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUU7WUFBRUcsTUFBTTtRQUFhO1FBQ3ZELElBQUlDLE9BQU81RCxTQUFTNkQsYUFBYSxDQUFDO1FBQ2xDRCxLQUFLRSxJQUFJLEdBQUdDLElBQUlDLGVBQWUsQ0FBQ1A7UUFDaENHLEtBQUtLLFFBQVEsR0FBRztRQUNoQkwsS0FBS00sS0FBSztJQUNaO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXguanM/YmVlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpbXVsYXRlLWJ1dHRvbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2ltdWxhdGVDYWNoZSk7XG5cbiAgZnVuY3Rpb24gc2ltdWxhdGVDYWNoZSgpIHtcbiAgICBjb25zdCBibG9ja1NpemUgPSBwYXJzZUludChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmxvY2stc2l6ZScpLnZhbHVlKTtcbiAgICBjb25zdCBtYWluTWVtb3J5SW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbi1tZW1vcnknKS52YWx1ZTtcbiAgICBjb25zdCBtYWluTWVtb3J5VHlwZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtYWluLW1lbW9yeS10eXBlJykudmFsdWU7XG4gICAgY29uc3QgY2FjaGVNZW1vcnlJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWNoZS1tZW1vcnknKS52YWx1ZTtcbiAgICBjb25zdCBjYWNoZU1lbW9yeVR5cGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FjaGUtbWVtb3J5LXR5cGUnKS52YWx1ZTtcbiAgICBjb25zdCBwcm9ncmFtRmxvd0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2dyYW0tZmxvdycpLnZhbHVlO1xuICAgIGNvbnN0IGNhY2hlQWNjZXNzVGltZSA9IHBhcnNlSW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWNoZS1hY2Nlc3MtdGltZScpLnZhbHVlKTtcbiAgICBjb25zdCBtZW1vcnlBY2Nlc3NUaW1lID0gcGFyc2VJbnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lbW9yeS1hY2Nlc3MtdGltZScpLnZhbHVlKTtcblxuICAgIC8vIENvbnZlcnQgcHJvZ3JhbSBmbG93IGlucHV0IGludG8gYmxvY2tzIGlmIG5lY2Vzc2FyeVxuICAgIGNvbnN0IHByb2dyYW1GbG93ID0gcHJvZ3JhbUZsb3dJbnB1dC5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuXG4gICAgLy8gQ29udmVydCBtYWluIG1lbW9yeSBzaXplIGFuZCBjYWNoZSBtZW1vcnkgc2l6ZSBpbnRvIGJsb2Nrc1xuICAgIGNvbnN0IG1haW5NZW1vcnlTaXplID0gbWFpbk1lbW9yeVR5cGUgPT09ICdibG9ja3MnXG4gICAgICAgID8gcGFyc2VJbnQobWFpbk1lbW9yeUlucHV0KVxuICAgICAgICA6IE1hdGguY2VpbChwYXJzZUludChtYWluTWVtb3J5SW5wdXQpIC8gYmxvY2tTaXplKTtcblxuICAgIGNvbnN0IGNhY2hlTWVtb3J5U2l6ZSA9IGNhY2hlTWVtb3J5VHlwZSA9PT0gJ2Jsb2NrcydcbiAgICAgICAgPyBwYXJzZUludChjYWNoZU1lbW9yeUlucHV0KVxuICAgICAgICA6IE1hdGguY2VpbChwYXJzZUludChjYWNoZU1lbW9yeUlucHV0KSAvIGJsb2NrU2l6ZSk7XG5cbiAgICAvLyBJbml0aWFsaXplIGNhY2hlIGFuZCBtYWluIG1lbW9yeVxuICAgIGxldCBjYWNoZSA9IFtdO1xuICAgIGxldCBtYWluTWVtb3J5ID0gbmV3IEFycmF5KG1haW5NZW1vcnlTaXplKS5maWxsKG51bGwpLm1hcCgoXywgaW5kZXgpID0+IGluZGV4KTtcblxuICAgIGxldCBoaXRzID0gMDtcbiAgICBsZXQgbWlzc2VzID0gMDtcbiAgICBsZXQgdGltZSA9IDA7XG5cbiAgICAvLyBDYWNoZSBzdHJ1Y3R1cmVcbiAgICBjb25zdCBjYWNoZUJsb2NrcyA9IGNhY2hlTWVtb3J5U2l6ZTtcbiAgICBjb25zdCBjYWNoZURhdGEgPSBuZXcgQXJyYXkoY2FjaGVCbG9ja3MpLmZpbGwobnVsbCk7XG4gICAgY29uc3QgY2FjaGVUaW1lID0gbmV3IEFycmF5KGNhY2hlQmxvY2tzKS5maWxsKDApO1xuXG4gICAgLy8gVHJhY2sgdGltZVxuICAgIGxldCBjdXJyZW50VGltZSA9IDA7XG5cbiAgICBwcm9ncmFtRmxvdy5mb3JFYWNoKGFkZHJlc3MgPT4ge1xuICAgICAgICBsZXQgYmxvY2sgPSBNYXRoLmZsb29yKGFkZHJlc3MgLyBibG9ja1NpemUpO1xuICAgICAgICBsZXQgaW5kZXggPSBjYWNoZURhdGEuaW5kZXhPZihibG9jayk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gQ2FjaGUgaGl0XG4gICAgICAgICAgICBoaXRzKys7XG4gICAgICAgICAgICB0aW1lICs9IGNhY2hlQWNjZXNzVGltZTsgLy8gQWRkIGNhY2hlIGFjY2VzcyB0aW1lIG9uIGhpdFxuICAgICAgICAgICAgY2FjaGVUaW1lW2luZGV4XSA9ICsrY3VycmVudFRpbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYWNoZSBtaXNzXG4gICAgICAgICAgICBtaXNzZXMrKztcbiAgICAgICAgICAgIHRpbWUgKz0gbWVtb3J5QWNjZXNzVGltZTsgLy8gQWRkIG1lbW9yeSBhY2Nlc3MgdGltZSBvbiBtaXNzXG4gICAgICAgICAgICBpZiAoY2FjaGVEYXRhLmxlbmd0aCA8IGNhY2hlTWVtb3J5U2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIENhY2hlIG5vdCBmdWxsLCBqdXN0IGFkZCBuZXcgYmxvY2tcbiAgICAgICAgICAgICAgICBjYWNoZURhdGFbY2FjaGVEYXRhLmluZGV4T2YobnVsbCldID0gYmxvY2s7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhY2hlIGZ1bGwsIHJlcGxhY2UgbGVhc3QgcmVjZW50bHkgdXNlZCBibG9ja1xuICAgICAgICAgICAgICAgIGxldCBscnVJbmRleCA9IGNhY2hlVGltZS5pbmRleE9mKE1hdGgubWluKC4uLmNhY2hlVGltZSkpO1xuICAgICAgICAgICAgICAgIGNhY2hlRGF0YVtscnVJbmRleF0gPSBibG9jaztcbiAgICAgICAgICAgICAgICBjYWNoZVRpbWVbbHJ1SW5kZXhdID0gKytjdXJyZW50VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VGltZSsrOyAvLyBBZGQgMSB1bml0IG9mIHRpbWUgZm9yIHRoZSBtZW1vcnkgYWNjZXNzXG4gICAgfSk7XG5cbiAgICAvLyBDYWxjdWxhdGlvbnNcbiAgICBjb25zdCB0b3RhbEFjY2Vzc2VzID0gcHJvZ3JhbUZsb3cubGVuZ3RoO1xuICAgIGNvbnN0IGhpdFJhdGUgPSBoaXRzIC8gdG90YWxBY2Nlc3NlcztcbiAgICBjb25zdCBtaXNzUmF0ZSA9IG1pc3NlcyAvIHRvdGFsQWNjZXNzZXM7XG4gICAgY29uc3QgbWlzc1BlbmFsdHkgPSAxMTsgLy8gZ2l2ZW5cbiAgICBjb25zdCBhdmVyYWdlQWNjZXNzVGltZSA9IGhpdFJhdGUgKiBjYWNoZUFjY2Vzc1RpbWUgKyBtaXNzUmF0ZSAqIG1pc3NQZW5hbHR5O1xuICAgIGNvbnN0IHRvdGFsQWNjZXNzVGltZSA9IChoaXRzICogYmxvY2tTaXplICogY2FjaGVBY2Nlc3NUaW1lKSArIChtaXNzZXMgKiBibG9ja1NpemUgKiBtaXNzUGVuYWx0eSkgKyAobWlzc2VzICogY2FjaGVBY2Nlc3NUaW1lKTtcblxuICAgIC8vIERpc3BsYXkgcmVzdWx0c1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoaXRzJykuaW5uZXJUZXh0ID0gYENhY2hlIEhpdHM6ICR7aGl0c30vJHt0b3RhbEFjY2Vzc2VzfWA7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pc3NlcycpLmlubmVyVGV4dCA9IGBDYWNoZSBNaXNzZXM6ICR7bWlzc2VzfS8ke3RvdGFsQWNjZXNzZXN9YDtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXZlcmFnZS1hY2Nlc3MtdGltZScpLmlubmVyVGV4dCA9IGBBdmVyYWdlIE1lbW9yeSBBY2Nlc3MgVGltZTogJHthdmVyYWdlQWNjZXNzVGltZS50b0ZpeGVkKDIpfW5zYDtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG90YWwtYWNjZXNzLXRpbWUnKS5pbm5lclRleHQgPSBgVG90YWwgTWVtb3J5IEFjY2VzcyBUaW1lOiAke3RvdGFsQWNjZXNzVGltZX1uc2A7XG5cbiAgICAvLyBDYWNoZSBzbmFwc2hvdFxuICAgIGxldCBjYWNoZVNuYXBzaG90ID0gY2FjaGVEYXRhLm1hcCgoYmxvY2ssIGlkeCkgPT4gYEJsb2NrICR7aWR4fTogJHtibG9ja31gKS5qb2luKCdcXG4nKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FjaGUtc25hcHNob3QnKS5pbm5lclRleHQgPSBjYWNoZVNuYXBzaG90O1xuICB9XG5cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkLXJlc3VsdHMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGRvd25sb2FkUmVzdWx0cyk7XG5cbiAgZnVuY3Rpb24gZG93bmxvYWRSZXN1bHRzKCkge1xuICAgIGxldCByZXN1bHRUZXh0ID0gYFxuICAgICAgSGl0czogJHtkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGl0cycpLmlubmVyVGV4dH1cbiAgICAgIE1pc3NlczogJHtkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWlzc2VzJykuaW5uZXJUZXh0fVxuICAgICAgQXZlcmFnZSBNZW1vcnkgQWNjZXNzIFRpbWU6ICR7ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F2ZXJhZ2UtYWNjZXNzLXRpbWUnKS5pbm5lclRleHR9XG4gICAgICBUb3RhbCBNZW1vcnkgQWNjZXNzIFRpbWU6ICR7ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsLWFjY2Vzcy10aW1lJykuaW5uZXJUZXh0fVxuICAgICAgQ2FjaGUgU25hcHNob3Q6ICR7ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhY2hlLXNuYXBzaG90JykuaW5uZXJUZXh0fVxuICAgIGA7XG4gICAgbGV0IGJsb2IgPSBuZXcgQmxvYihbcmVzdWx0VGV4dF0sIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pO1xuICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgbGluay5kb3dubG9hZCA9ICdjYWNoZV9zaW11bGF0aW9uX3Jlc3VsdHMudHh0JztcbiAgICBsaW5rLmNsaWNrKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNpbXVsYXRlQ2FjaGUiLCJibG9ja1NpemUiLCJwYXJzZUludCIsInZhbHVlIiwibWFpbk1lbW9yeUlucHV0IiwibWFpbk1lbW9yeVR5cGUiLCJxdWVyeVNlbGVjdG9yIiwiY2FjaGVNZW1vcnlJbnB1dCIsImNhY2hlTWVtb3J5VHlwZSIsInByb2dyYW1GbG93SW5wdXQiLCJjYWNoZUFjY2Vzc1RpbWUiLCJtZW1vcnlBY2Nlc3NUaW1lIiwicHJvZ3JhbUZsb3ciLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsIm1haW5NZW1vcnlTaXplIiwiTWF0aCIsImNlaWwiLCJjYWNoZU1lbW9yeVNpemUiLCJjYWNoZSIsIm1haW5NZW1vcnkiLCJBcnJheSIsImZpbGwiLCJfIiwiaW5kZXgiLCJoaXRzIiwibWlzc2VzIiwidGltZSIsImNhY2hlQmxvY2tzIiwiY2FjaGVEYXRhIiwiY2FjaGVUaW1lIiwiY3VycmVudFRpbWUiLCJmb3JFYWNoIiwiYWRkcmVzcyIsImJsb2NrIiwiZmxvb3IiLCJpbmRleE9mIiwibGVuZ3RoIiwibHJ1SW5kZXgiLCJtaW4iLCJ0b3RhbEFjY2Vzc2VzIiwiaGl0UmF0ZSIsIm1pc3NSYXRlIiwibWlzc1BlbmFsdHkiLCJhdmVyYWdlQWNjZXNzVGltZSIsInRvdGFsQWNjZXNzVGltZSIsImlubmVyVGV4dCIsInRvRml4ZWQiLCJjYWNoZVNuYXBzaG90IiwiaWR4Iiwiam9pbiIsImRvd25sb2FkUmVzdWx0cyIsInJlc3VsdFRleHQiLCJibG9iIiwiQmxvYiIsInR5cGUiLCJsaW5rIiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJkb3dubG9hZCIsImNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/index.js\n"));

/***/ })

});